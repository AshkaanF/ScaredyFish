geom_raster() +
geom_point( data = current[ current$ratio > 1, ],
aes( x = Var1, y = Var2, fill = ratio, size = ratio ),
shape = 22, alpha = 0.75, stroke = 0.01, colour = '#f0f0f0',
inherit.aes = F ) +
scale_fill_gradientn( colours = c( '#000000', '#d9d9d9', '#f0f0f0', '#ffff33', '#e41a1c' ),
limits = c( 0, 2 ), guide = F ) +
scale_size_continuous( range = c( 0.025, 0.5 ), trans = 'exp', limits = c( 1, 2 ), guide = F ) +
theme( aspect.ratio = my.aspect,
panel.background = element_rect(fill = "black", color  =  NA),
plot.background = element_rect(color = "black", fill = "black" ) ) +
coord_flip()
ggplot(data = current, aes( x = Var1, y = Var2, fill = ratio ) ) +
theme_blank() +
geom_raster() +
geom_point( data = current[ current$ratio > 1, ],
aes( x = Var1, y = Var2, fill = ratio, size = ratio ),
shape = 22, alpha = 0.75, stroke = 0.025, colour = '#000000',
inherit.aes = F ) +
scale_fill_gradientn( colours = c( '#000000', '#d9d9d9', '#f0f0f0', '#ffff33', '#e41a1c' ),
limits = c( 0, 2 ), guide = F ) +
scale_size_continuous( range = c( 0.025, 0.5 ), trans = 'exp', limits = c( 1, 2 ), guide = F ) +
theme( aspect.ratio = my.aspect,
panel.background = element_rect(fill = "black", color  =  NA),
plot.background = element_rect(color = "black", fill = "black" ) ) +
coord_flip()
## -
## work
## -
for( f in 2 : max( res$time ) ) {
## grab a dataframe you want to use
current <- tile.grid
## append column
current$ratio <- current$value
## grab stats for each tile
current.res <- res[ res$time == f, ]
## summarise tiles
sum.res <- current.res %>%
group_by( 'rx' = round( x ), 'ry' = round( y ) ) %>%
summarise( 'n' = length( state ),
'r' = sum( state ) ) %>%
as.data.frame()
## fill data frame
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] <-
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] +
( sum.res$r[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] /
sum.res$n[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] )
## if
if( f == 2 ) { last <- current }
## average from last step
current$ratio <- ( current$ratio + ( current$ratio + last$ratio ) / 2 ) / 2
##
## can i show when groups initiate?
##
## ggplot
gg.tile <- ggplot(data = current, aes( x = Var1, y = Var2, fill = ratio ) ) +
theme_blank() +
geom_raster() +
geom_point( data = current[ current$ratio > 1, ],
aes( x = Var1, y = Var2, fill = ratio, size = ratio ),
shape = 22, alpha = 0.75, stroke = 0.025, colour = '#000000',
inherit.aes = F ) +
scale_fill_gradientn( colours = c( '#000000', '#d9d9d9', '#f0f0f0', '#ffff33', '#e41a1c' ),
limits = c( 0, 2 ), guide = F ) +
scale_size_continuous( range = c( 0.025, 0.5 ), trans = 'exp', limits = c( 1, 2 ), guide = F ) +
theme( aspect.ratio = my.aspect,
panel.background = element_rect(fill = "black", color  =  NA),
plot.background = element_rect(color = "black", fill = "black" ) ) +
coord_flip()
##
## viz output
##
## generate a filename for the frame
fn <- paste('../animation_assets/z_frame',
sprintf("%05d", f),
sep = '_') %>%
paste(., 'png', sep = '.')
## vector
png(filename = fn,
width     = 2.95,
height    = 2.95,
units     = 'in',
res       = 480,
bg = 'black'
)
## print network
print( gg.tile )
## print
dev.off()
## drop a line
cat( f, 'printed\n' )
## save last frame
last = current
}
## -
## work
## -
for( f in 2 : max( res$time ) ) {
## grab a dataframe you want to use
current <- tile.grid
## append column
current$ratio <- current$value
## grab stats for each tile
current.res <- res[ res$time == f, ]
## summarise tiles
sum.res <- current.res %>%
group_by( 'rx' = round( x ), 'ry' = round( y ) ) %>%
summarise( 'n' = length( state ),
'r' = sum( state ) ) %>%
as.data.frame()
## fill data frame
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] <-
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] +
( sum.res$r[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] /
sum.res$n[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] )
## if
if( f == 2 ) { last <- current }
## average from last step
current$ratio <- ( current$ratio + ( current$ratio + last$ratio ) / 2 ) / 2
##
## can i show when groups initiate?
##
## ggplot
gg.tile <- ggplot(data = current, aes( x = Var1, y = Var2, fill = ratio ) ) +
theme_blank() +
geom_raster() +
geom_point( data = current[ current$ratio > 1, ],
aes( x = Var1, y = Var2, fill = ratio, size = ratio ),
shape = 22, alpha = 0.75, stroke = 0.025, colour = '#000000',
inherit.aes = F ) +
scale_fill_gradientn( colours = c( '#000000', '#d9d9d9', '#f0f0f0', '#ffff33', '#e41a1c' ),
limits = c( 0, 2 ), guide = F ) +
scale_size_continuous( range = c( 0.025, 0.5 ), limits = c( 1, 2 ), guide = F ) +
theme( aspect.ratio = my.aspect,
panel.background = element_rect(fill = "black", color  =  NA),
plot.background = element_rect(color = "black", fill = "black" ) ) +
coord_flip()
##
## viz output
##
## generate a filename for the frame
fn <- paste('../animation_assets/z_frame',
sprintf("%05d", f),
sep = '_') %>%
paste(., 'png', sep = '.')
## vector
png(filename = fn,
width     = 2.95,
height    = 2.95,
units     = 'in',
res       = 480,
bg = 'black'
)
## print network
print( gg.tile )
## print
dev.off()
## drop a line
cat( f, 'printed\n' )
## save last frame
last = current
}
## -
## work
## -
for( f in 2 : max( res$time ) ) {
## grab a dataframe you want to use
current <- tile.grid
## append column
current$ratio <- current$value
## grab stats for each tile
current.res <- res[ res$time == f, ]
## summarise tiles
sum.res <- current.res %>%
group_by( 'rx' = round( x ), 'ry' = round( y ) ) %>%
summarise( 'n' = length( state ),
'r' = sum( state ) ) %>%
as.data.frame()
## fill data frame
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] <-
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] +
( sum.res$r[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] /
sum.res$n[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] )
## if
if( f == 2 ) { last <- current }
## average from last step
current$ratio <- ( current$ratio + ( current$ratio + last$ratio ) / 2 ) / 2
##
## can i show when groups initiate?
##
## ggplot
gg.tile <- ggplot(data = current, aes( x = Var1, y = Var2, fill = ratio ) ) +
theme_blank() +
geom_raster() +
geom_point( data = current[ current$ratio > 1, ],
aes( x = Var1, y = Var2, fill = ratio, size = ratio ),
shape = 22, alpha = 0.75, stroke = 0.1, colour = '#000000',
inherit.aes = F ) +
scale_fill_gradientn( colours = c( '#000000', '#d9d9d9', '#f0f0f0', '#ffff33', '#e41a1c' ),
limits = c( 0, 2 ), guide = F ) +
scale_size_continuous( range = c( 0.025, 0.5 ), limits = c( 1, 2 ), guide = F ) +
theme( aspect.ratio = my.aspect,
panel.background = element_rect(fill = "black", color  =  NA),
plot.background = element_rect(color = "black", fill = "black" ) ) +
coord_flip()
##
## viz output
##
## generate a filename for the frame
fn <- paste('../animation_assets/z_frame',
sprintf("%05d", f),
sep = '_') %>%
paste(., 'png', sep = '.')
## vector
png(filename = fn,
width     = 2.95,
height    = 2.95,
units     = 'in',
res       = 480,
bg = 'black'
)
## print network
print( gg.tile )
## print
dev.off()
## drop a line
cat( f, 'printed\n' )
## save last frame
last = current
}
x = 1000 * c( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 )
x
y= c( 0.402, 2.48, 3.85, 6.67, 14.86, 20.25, 37.7, 39.18 ) / 10
x = 1000 * c( 1, 2, 3, 4, 5, 6, 7, 8 )
plot( y ~ x )
dim(tile)
610 / 500
500 / 610
100 / 138
0.8196 * 0.7246
8.3 / 100
View(tile)
sum( tile )
0.4 * sum( tile )
0.5 * sum( tile )
mean( tile )
500 * 100
0.5 * ( 500 * 100 )
0.5 * ( 0.5 * ( 500 * 100 ) )
0.4 * ( 0.5 * ( 500 * 100 ) )
69.94 / 15
4.6627 * 100
(4.6627 * 100) / 60
599.6 / 100
dev.off()
## prep
if( !require( RColorBrewer ) ) { install.packages( 'RColorBrewer' ) }; library( RColorBrewer )
if( !require( magrittr ) ) { install.packages( 'magrittr' ) }; library( magrittr )
if( !require( ggnetwork ) ) { install.packages( 'ggnetwork' ) }; library( ggnetwork )
if( !require( ggplot2 ) ) { install.packages( 'ggplot2' ) }; library( ggplot2 )
if( !require( dplyr ) ) { install.packages( 'dplyr' ) }; library( dplyr )
if( !require( OpenImageR ) ) { install.packages( 'OpenImageR' ) }
if( !require( reshape2 ) ) { install.packages( 'reshape2' ) }
## load data
res <- read.table( './out.tsv', sep = '\t' )
## add header
names( res ) <- c( 'time', 'id', 'x', 'y', 'state', 'in.a.patch' )
## remove goners
res <- res[ res$x > -1e5, ]
## get range of my arena
arena_x <- range( res$x ) + c(-1, 1)
arena_y <- range( res$y ) + c(-1, 1)
## aspect ratio of plot
my.aspect <- diff( arena_x ) / diff( arena_y )
## load and melt
tile <- as.matrix( read.table( './landscape.tsv', header = F, sep = '\t' ) )
# tile <- OpenImageR::down_sample_image( tile, factor = 1, gaussian_blur = T )
tile.grid <- melt( tile )
tile.grid$Var2 <- as.numeric( gsub( 'V', '', tile.grid$Var2 ) )
## plot
ggplot(data = tile.grid, aes( Var1, Var2, fill = ( value ) ) ) +
geom_raster() +
scale_fill_gradientn( colours = c( '#000000', '#f7f7f7' ), guide = F ) +
theme( aspect.ratio = my.aspect ) +
coord_flip()
## -
## work
## -
for( f in 2 : max( res$time ) ) {
## grab a dataframe you want to use
current <- tile.grid
## append column
current$ratio <- current$value
## grab stats for each tile
current.res <- res[ res$time == f, ]
## summarise tiles
sum.res <- current.res %>%
group_by( 'rx' = round( x ), 'ry' = round( y ) ) %>%
summarise( 'n' = length( state ),
'r' = sum( state ) ) %>%
as.data.frame()
## fill data frame
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] <-
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] +
( sum.res$r[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] /
sum.res$n[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] )
## if
if( f == 2 ) { last <- current }
## average from last step
current$ratio <- ( current$ratio + ( current$ratio + last$ratio ) / 2 ) / 2
##
## can i show when groups initiate?
##
## ggplot
gg.tile <- ggplot(data = current, aes( x = Var1, y = Var2, fill = ratio ) ) +
theme_blank() +
geom_raster() +
geom_point( data = current[ current$ratio > 1, ],
aes( x = Var1, y = Var2, fill = ratio, size = ratio ),
shape = 22, alpha = 0.75, stroke = 0.1, colour = '#000000',
inherit.aes = F ) +
scale_fill_gradientn( colours = c( '#000000', '#d9d9d9', '#f0f0f0', '#ffff33', '#e41a1c' ),
limits = c( 0, 2 ), guide = F ) +
scale_size_continuous( range = c( 0.025, 0.5 ), limits = c( 1, 2 ), guide = F ) +
theme( aspect.ratio = my.aspect,
panel.background = element_rect(fill = "black", color  =  NA),
plot.background = element_rect(color = "black", fill = "black" ) ) +
coord_flip()
##
## viz output
##
## generate a filename for the frame
fn <- paste('../animation_assets/z_frame',
sprintf("%05d", f),
sep = '_') %>%
paste(., 'png', sep = '.')
## vector
png(filename = fn,
width     = 2.95,
height    = 2.95,
units     = 'in',
res       = 480,
bg = 'black'
)
## print network
print( gg.tile )
## print
dev.off()
## drop a line
cat( f, 'printed\n' )
## save last frame
last = current
}
f = 99
## grab a dataframe you want to use
current <- tile.grid
## append column
current$ratio <- current$value
## grab stats for each tile
current.res <- res[ res$time == f, ]
## summarise tiles
sum.res <- current.res %>%
group_by( 'rx' = round( x ), 'ry' = round( y ) ) %>%
summarise( 'n' = length( state ),
'r' = sum( state ) ) %>%
as.data.frame()
## fill data frame
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] <-
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] +
( sum.res$r[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] /
sum.res$n[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] )
## grab a dataframe you want to use
current <- tile.grid
## append column
current$ratio <- current$value
## grab stats for each tile
current.res <- res[ res$time == f, ]
## summarise tiles
sum.res <- current.res %>%
group_by( 'rx' = round( x ), 'ry' = round( y ) ) %>%
summarise( 'n' = length( state ),
'r' = sum( state ) ) %>%
as.data.frame()
## fill data frame
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] <-
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] +
( sum.res$r[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] /
sum.res$n[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] )
## ggplot
gg.tile <- ggplot(data = current, aes( x = Var1, y = Var2, fill = ratio ) ) +
theme_blank() +
geom_raster() +
geom_point( data = current[ current$ratio > 1, ],
aes( x = Var1, y = Var2, fill = ratio, size = ratio ),
shape = 22, alpha = 0.75, stroke = 0.1, colour = '#000000',
inherit.aes = F ) +
scale_fill_gradientn( colours = c( '#000000', '#d9d9d9', '#f0f0f0', '#ffff33', '#e41a1c' ),
limits = c( 0, 2 ), guide = F ) +
scale_size_continuous( range = c( 0.025, 0.5 ), limits = c( 1, 2 ), guide = F ) +
theme( aspect.ratio = my.aspect,
panel.background = element_rect(fill = "black", color  =  NA),
plot.background = element_rect(color = "black", fill = "black" ) ) +
coord_flip()
gg.tile
ggplot(data = current, aes( x = Var1, y = Var2, fill = ratio ) ) +
theme_blank() +
geom_raster() +
geom_point( data = current[ current$ratio > 1, ],
aes( x = Var1, y = Var2, fill = ratio, size = ratio ),
shape = 21, alpha = 0.75, stroke = 0.1, colour = '#f7f7f7',
inherit.aes = F ) +
scale_fill_gradientn( colours = c( '#000000', '#d9d9d9', '#f0f0f0', '#ffff33', '#e41a1c' ),
limits = c( 0, 2 ), guide = F ) +
scale_size_continuous( range = c( 0.03, 0.9 ), limits = c( 1, 2 ), guide = F ) +
theme( aspect.ratio = my.aspect,
panel.background = element_rect(fill = "black", color  =  NA),
plot.background = element_rect(color = "black", fill = "black" ) ) +
coord_flip()
## -
## work
## -
for( f in 2 : max( res$time ) ) {
## grab a dataframe you want to use
current <- tile.grid
## append column
current$ratio <- current$value
## grab stats for each tile
current.res <- res[ res$time == f, ]
## summarise tiles
sum.res <- current.res %>%
group_by( 'rx' = round( x ), 'ry' = round( y ) ) %>%
summarise( 'n' = length( state ),
'r' = sum( state ) ) %>%
as.data.frame()
## fill data frame
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] <-
current$ratio[ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] +
( sum.res$r[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] /
sum.res$n[ prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ][ !is.na( prodlim::row.match( current[, 1 : 2 ], sum.res[, 1 : 2 ] ) ) ] )
## if
# if( f == 2 ) { last <- current }
## average from last step
# current$ratio <- ( current$ratio + ( current$ratio + last$ratio ) / 2 ) / 2
##
## can i show when groups initiate?
##
## ggplot
gg.tile <- ggplot(data = current, aes( x = Var1, y = Var2, fill = ratio ) ) +
theme_blank() +
geom_raster() +
geom_point( data = current[ current$ratio > 1, ],
aes( x = Var1, y = Var2, fill = ratio, size = ratio ),
shape = 21, alpha = 0.75, stroke = 0.1, colour = '#f7f7f7',
inherit.aes = F ) +
scale_fill_gradientn( colours = c( '#000000', '#d9d9d9', '#f0f0f0', '#ffff33', '#e41a1c' ),
limits = c( 0, 2 ), guide = F ) +
scale_size_continuous( range = c( 0.03, 0.9 ), limits = c( 1, 2 ), guide = F ) +
theme( aspect.ratio = my.aspect,
panel.background = element_rect(fill = "black", color  =  NA),
plot.background = element_rect(color = "black", fill = "black" ) ) +
coord_flip()
##
## viz output
##
## generate a filename for the frame
fn <- paste('../animation_assets/z_frame',
sprintf("%05d", f),
sep = '_') %>%
paste(., 'png', sep = '.')
## vector
png(filename = fn,
width     = 2.95,
height    = 2.95,
units     = 'in',
res       = 480,
bg = 'black'
)
## print network
print( gg.tile )
## print
dev.off()
## drop a line
cat( f, 'printed\n' )
## save last frame
# last = current
}
View(tile)
View(res)
hist( rnornm( 1e4, 0, 0.5))
hist( rnorn( 1e4, 0, 0.5))
hist( rnorm( 1e4, 0, 0.5))
hist( rnorm( 1e4, 0, 1))
hist( rnorm( 1e4, 0, 0.75) )
hist( rnorm( 1e4, 0, 0.5) )
rnorm( 1, 0, 0.5 )
rnorm( 1, 0, 0.5 )
rnorm( 1, 0, 0.5 )
rnorm( 1, 0, 0.5 )
rnorm( 1, 0, 0.5 )
rnorm( 1, 0, 0.5 )
rnorm( 1, 0, 0.5 )
rnorm( 1, 0, 0.5 )
rnorm( 1, 0, 0.5 )
rnorm( 1, 0, 0.5 )
dim(landscape)
dim(tile)
0.5 * (610 * 138)
500 * 100
(0.5 * (610 * 138)) / 5e4
(610 / 500) (138/100)
(610 / 500) *'' (138/100)
(610 / 500) * (138/100)
